# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import (worker, steps, changes, schedulers, util,
                              reporters)

import toolz
import operator
from ursabot.docker import worker_images
from ursabot.hooks import GithubHook

try:
    from local import (PRODUCTION, BUILDBOT_URL, ZULIP, EMAIL, WORKER_PORT,
                       HOSTS, WEBUI_PORT, AUTH, AUTHZ, DATABASE_URL,
                       WORKER_PASSWORD, CHANGE_PORT, CHANGE_USER,
                       CHANGE_PASSWORD, GITHUB_TOKEN, GITHUB_HOOK_SECRET,
                       TRY_SCHEDULER_PORT, TRY_SCHEDULER_USERPASS)
except ImportError:
    from buildbot.www.auth import NoAuth
    PRODUCTION = False
    BUILDBOT_URL = 'http://localhost:9011/'
    DATABASE_URL = 'sqlite:///buildbot.sqlite'
    EMAIL = 'test@buildbot'
    ZULIP = None
    HOSTS = None
    WORKER_PORT = 9021
    WEBUI_PORT = 8080
    AUTH = NoAuth()
    AUTHZ = util.Authz()
    GITHUB_TOKEN = None
    CHANGE_PORT = 9041
    CHANGE_USER = 'test'
    CHANGE_PASSWORD = 'testpw'
    GITHUB_HOOK_SECRET = None


print(f'IS PRODUCTION: {PRODUCTION}')

# Hierarchy worker -> builder -> scheduler

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['buildbotNetUsageData'] = None

# the 'title' string will appear at the top of this buildbot installation's
# home pages (linked to the 'titleURL').
c['title'] = 'Ursa-Labs Buildbot'
c['titleURL'] = 'http://nashville.ursalabs.org:4100'
c['buildbotURL'] = BUILDBOT_URL

c['workers'] = []
c['builders'] = []
c['schedulers'] = []


####### CODEBASES

# Associate a codebase with the `change` based on the repository
# repositories = {
#     'https://github.com/ursa-labs/ursabot': 'ursabot',
#     'https://github.com/apache/arrow': 'arrow'
# }
#
# c['codebaseGenerator'] = lambda change: repositories[change['repository']]

####### WORKERS

# 'protocols' contains information about protocols which master will use for
# communicating with workers. You must define at least 'port' option that
# workers could connect to your master with this protocol.
# 'port' must match the value configured into the workers (with their
# --master option)
c['protocols'] = {'pb': {'port': WORKER_PORT}}

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password. The same
# worker name and password must be configured on the worker.

# TODO: set worker's defaultProperties
# TODO: support specifying parameters to improve isolation, like:
#   cpu_shares, isolation(cgroups), mem_limit and runtime (which will be
#   required for nvidia builds)
# https://docker-py.readthedocs.io/en/stable/api.html
# docker.api.container.ContainerApiMixin.create_host_config

if HOSTS:
    c['workers'] = [
        worker.Worker('dgx1', WORKER_PASSWORD),
    ]

    # create workers for ursabot builds - using plain python docker images
    ursabot_workers = []
    for host, attribs in HOSTS.items():
        # TODO(kszucs): nicer way to filter hosts by architecture
        if 'amd64' in attribs.get('docker_archs', set()):
            # TODO(kszucs): use a plain python image with a worker
            image = 'ursalab/amd64-ubuntu-18.04-conda-python-3.7:worker'
            image_name = 'python'
            w = worker.DockerLatentWorker(
                f'{host}-{image_name}', None,
                docker_host=attribs['docker_host'],
                image=image,
                autopull=True,
                alwaysPull=True,
                hostconfig=dict(network_mode='host')
            )
            ursabot_workers.append(w)
    c['workers'].extend(ursabot_workers)

    # workers for arrow
    workers_by_image = dict()

    # Add docker latent workers, We'll have a worker per docker image on each
    # host supporting tha image's architecture.
    for image in worker_images:
        workers = []
        for host, attribs in HOSTS.items():
            # Check that architecture is supported by the host machine.
            # Docker on mac supports multiple architectures whereas docker on
            # linux doesn't.
            image_name = image.repo.replace('.', '-')
            if image.arch in attribs.get('docker_archs', set()):
                w = worker.DockerLatentWorker(
                    f'{host}-{image_name}', None,
                    docker_host=attribs['docker_host'],
                    image=str(image),
                    autopull=True,
                    alwaysPull=True,
                    hostconfig=dict(network_mode='host')
                )
                workers.append(w)
        workers_by_image[image] = workers

    c['workers'].extend(toolz.concat(workers_by_image.values()))

    benchmark_worker = worker.DockerLatentWorker(
        'dgx2-amd64-ubuntu-18.04-benchmarks', None,
        docker_host=HOSTS['dgx2']['docker_host'],
        image='ursalab/amd64-ubuntu-18.04-cpp:worker',
        autopull=True,
        alwaysPull=True,
        hostconfig=dict(network_mode='host')
    )
    c['workers'].append(benchmark_worker)

else:
    c['workers'] = [worker.Worker('test-worker', 'test-secret')]


####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

c['change_source'] = [
    changes.GitPoller(
        repourl='https://github.com/apache/arrow',
        project='apache/arrow',
        branch='master',
        pollInterval=180
    ),
    changes.GitHubPullrequestPoller(
        owner='apache',
        repo='arrow',
        token=GITHUB_TOKEN,
        branches=['master'],
        pollInterval=180,
        magic_link=True
    ),
    changes.PBChangeSource(port=CHANGE_PORT, user=CHANGE_USER,
                           passwd=CHANGE_PASSWORD)
]


####### FACTORIES

from ursabot.factories import (BuildFactory, cpp, python, cpp_conda,
                               cpp_benchmarks, python_conda, ursabot_test,
                               ursabot_docker_build)


####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform
# a build: what steps, and which workers can execute them.  Note that any
# particular build will only take place on one worker.

# trigger

if HOSTS:
    # Ursabot builders
    ursabot_builders = [
        util.BuilderConfig(
            name='ursabot-test',
            factory=ursabot_test,
            workernames=[w.name for w in ursabot_workers],
            tags=['docker', 'python']
        ),
        # TODO(kszucs): it doesn't actually require a worker
        util.BuilderConfig(
            name='ursabot-docker-build',
            factory=ursabot_docker_build,
            workernames=[w.name for w in ursabot_workers],
            tags=['docker', 'python']
        )
    ]
    c['builders'] = list(ursabot_builders)  # copy

    # Arrow builders
    arrow_builders = []
    for image in worker_images:
        # Reduce the number of ARM builds
        if image.arch == 'arm64v8' and image.os.startswith('alpine'):
            continue

        # TODO(kszucs): create a mapping between the images(environments) and
        # the build factories
        if image.name.startswith('cpp'):
            if image.variant == 'conda':
                factory = cpp_conda
            else:
                factory = cpp
        elif image.name.startswith('python'):
            if image.variant == 'conda':
                factory = python_conda
            else:
                factory = python
        else:
            raise ValueError(f'Unsupported build {image.name}')

        b = util.BuilderConfig(
            name=image.repo,
            factory=factory,
            workernames=[w.name for w in workers_by_image[image]],
            tags=['docker'] + list(image.platform)
        )
        arrow_builders.append(b)
    c['builders'].extend(arrow_builders)

    benchmark_builder = util.BuilderConfig(
        name="amd64-ubuntu-18.04-cpp-benchmark",
        factory=cpp_benchmarks,
        workernames=[dgx2-amd64-ubuntu-18.04-benchmarks],
        tags=['docker', 'benchmark', 'amd64', 'ubuntu-18.04']
    )
    c['builders'].append(benchmark_builder)

else:
    # for testing
    c['builders'] = [
        util.BuilderConfig(
            name='test-builder',
            workernames=['test-worker'],
            factory=BuildFactory()
        )
    ]


# trigger


####### SCHEDULERS

if HOSTS:
    def extract_names(builders):
        return [b.name for b in builders]

    c['schedulers'] = [
        schedulers.AnyBranchScheduler(
            name='arrow',
            change_filter=util.ChangeFilter(
                project='apache/arrow'
            ),
            treeStableTimer=None,
            builderNames=extract_names(arrow_builders)
        ),
        schedulers.AnyBranchScheduler(
            name='ursabot',
            change_filter=util.ChangeFilter(
                project='ursa-labs/ursabot',
            ),
            treeStableTimer=None,
            builderNames=extract_names(ursabot_builders)
        ),
        schedulers.ForceScheduler(
            name='force',
            builderNames=extract_names(ursabot_builders + arrow_builders)
        ),
        schedulers.Try_Userpass(
            name='try',
            builderNames=extract_names(ursabot_builders + arrow_builders),
            port=TRY_SCHEDULER_PORT,
            userpass=TRY_SCHEDULER_USERPASS
        )
    ]
else:
    # for testing
    c['schedulers'] = [
        schedulers.ForceScheduler(
            name='force',
            builderNames=['test-builder']
        )
    ]

####### BUILDBOT SERVICES

# 'services' is a list of BuildbotService items like reporter targets. The
# status of each build will be pushed to these targets. buildbot/reporters/*.py
# has a variety to choose from, like IRC bots.

template=u'''\
<h4>Build status: {{ summary }}</h4>
<p> Worker used: {{ workername }}</p>
{% for step in build['steps'] %}
<p> {{ step['name'] }}: {{ step['result'] }}</p>
{% endfor %}
<p><b> -- The Buildbot</b></p>
'''

c['services'] = [
    # have to provide repo:status scope for the token and write access to the
    # for the repositories
    reporters.GitHubStatusPush(
        token=GITHUB_TOKEN,
        context=util.Interpolate('buildbot/%(prop:buildername)s'),
        startDescription='Build started.',
        endDescription='Build done.',
        verbose=True
    )
]

if ZULIP:
    c['services'].append(
        reporters.MailNotifier(
            fromaddr=EMAIL,
            sendToInterestedUsers=False,
            extraRecipients=[ZULIP],
            messageFormatter=reporters.MessageFormatter(
                template=template,
                template_type='html',
                wantProperties=True,
                wantSteps=True
            )
        )
    )

# minimalistic config to activate new web UI
c['www'] = dict(
    port=WEBUI_PORT,
    auth=AUTH,
    authz=AUTHZ,
    plugins=dict(
        waterfall_view={},
        console_view={},
        grid_view={}
    ),
    change_hook_dialects={
        'github': {
            'class': GithubHook,
            'token': GITHUB_TOKEN,
            'secret': GITHUB_HOOK_SECRET,
            'debug': True,
        }
    }
)

####### DB URL

c['db'] =  {'db_url' : DATABASE_URL}
